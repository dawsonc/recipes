<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Recipe World</title>

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"
        integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

    <!-- React JS -->
    <script crossorigin="anonymous"
        src="https://cdnjs.cloudflare.com/ajax/libs/react/16.8.6/umd/react.production.min.js"></script>
    <script crossorigin="anonymous"
        src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.8.6/umd/react-dom.production.min.js"></script>

    <!-- Babel NOT FOR PROD -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"></script>

    <!-- sanitizer - should find a way to include this (or similar) via npm/webpack in the long term -->
    <script src="https://cdn.jsdelivr.net/gh/jitbit/HtmlSanitizer@master/HtmlSanitizer.js"></script>

    <!-- Custom styling -->
    <style>
        .text-editable {
            font-family: Consolas, Courier, monospace;
            border: 1px solid #ccc;
        }
    </style>
</head>

<body>
    <div class="container mt-3 mb-3">
        <div class="mb-3">
            <h1>Recipe World</h1>
        </div>

        <div id="recipeLibrary"></div>
    </div>

    <!-- RecipeList component -->
    <script type="text/babel">
        function RecipeLibrary() {
            // Shared state for the application
            // List of recipes to display
            const [recipeList, setRecipeList] = React.useState([]);
            // Active recipe to display in the recipe pane
            const [activeRecipe, setActiveRecipe] = React.useState({});
            // List of all tags
            const [tags, setTags] = React.useState([]);
            // List of active tags used to filter recipe list
            const [activeTags, setActiveTags] = React.useState([]);
            // Search query used to filter recipe list
            const [searchQuery, setSearchQuery] = React.useState("");
            // Whether or not the app is in editing mode
            const [editMode, setEditMode] = React.useState(false);
            // Whether or not the user is creating a new recipe
            const [creatingRecipe, setCreatingRecipe] = React.useState(false);
            // Whether or not we need to refresh the list of recipes
            const [refreshRecipeList, setRefreshRecipeList] = React.useState(false);

            // Fetch the recipe list from the server on load and again when
            // either the active tags or search query change
            React.useEffect(() => {
                fetch('/api/recipes?tags=' + activeTags.join(',') + '&q=' + searchQuery)
                    .then(response => response.json())
                    .then(data => setRecipeList(data));
            }, [activeTags, searchQuery, refreshRecipeList]);

            // Also fetch a list of all tags on load
            React.useEffect(() => {
                fetch('/api/recipes/tags')
                    .then(response => response.json())
                    .then(data => setTags(data));
            }, []);

            // Function for setting the active recipe by name
            function setActiveRecipeByName(name) {
                setActiveRecipe(recipeList.find((recipe) => recipe.Name === name));
            }

            // Function for getting a list of all inactive tags
            function inactiveTags(tags, activeTags) {
                return tags.filter((tag) => !activeTags.includes(tag));
            }

            // Function for activating a tag (adding it to the active tags list if it's
            // not already there)
            function activateTag(tag, activeTags) {
                if (activeTags.includes(tag)) {
                    return;
                }
                setActiveTags([...activeTags, tag]);
            }

            // Function for deactivating a tag (removing it from the active tags list)
            function deactivateTag(tag, activeTags) {
                setActiveTags(activeTags.filter((t) => t !== tag));
            }

            // Function for setting the active search query based on form changes
            function handleSearchTextChange(event) {
                setSearchQuery(event.target.value);
            }

            // Function for clearing the search query
            function handleClearSearchClick() {
                setText('');
            }

            // Function for toggling edit and creating mode on when the "Add Recipe"
            // button is clicked
            function handleAddRecipeButton() {
                // Set the active recipe to a blank recipe
                setActiveRecipe({
                    Name: "New Recipe",
                    Description: "An example of a new recipe",
                    Ingredients: [{ Name: "example ingredient", Quantity: "1 unit" }],
                    Steps: ["Example step 1", "Example step 2"],
                    Tags: [],
                    Comments: [],
                });

                // Activate editing mode and creating mode
                setEditMode(true);
                setCreatingRecipe(true);
            }

            // Disable the recipeBrowser when in edit mode
            // Grey out the recipe list and make it non-interactive if we're in edit mode
            var browserStyle;
            if (editMode) {
                browserStyle = { "opacity": 0.5, "pointer-events": "none" };
            } else {
                browserStyle = {};
            }

            return <div class="row">
                <div id="recipeBrowser" class="col-md-6" style={browserStyle}>
                    <div class="input-group mb-3">
                        <input type="text" class="form-control" placeholder="Search for a recipe" aria-
                            label="Search for a recipe" aria-describedby="button-addon2"
                            onChange={handleSearchTextChange}></input>
                    </div>

                    <div id="tagList" class="mb-3">
                        <TagList tags={tags} activeTags={activeTags} inactiveTags={inactiveTags}
                            activateTag={activateTag} deactivateTag={deactivateTag} />
                    </div>

                    <button type="button" onClick={handleAddRecipeButton} class="btn btn-primary col-md-12 mb-3">+ Add Recipe</button>

                    <div id="recipeList" class="col-md-12" style={{ "height": 800 + "px" }}>
                        <RecipeList recipes={recipeList} setActiveRecipe={setActiveRecipeByName} editMode={editMode} />
                    </div>
                </div>
                <div id="recipeFocusPane" class="col-md-6 border rounded">
                    <RecipePane activeRecipe={activeRecipe} editMode={editMode}
                        creatingRecipe={creatingRecipe} setEditMode={setEditMode}
                        setCreatingRecipe={setCreatingRecipe} setActiveRecipe={setActiveRecipe}
                        setActiveRecipeByName={setActiveRecipeByName}
                        refreshRecipeList={refreshRecipeList} setRefreshRecipeList={setRefreshRecipeList} />
                </div>
            </div>
        }

        function RecipeRow({ key, name, tags, setActiveRecipe }) {
            function handleClick() {
                setActiveRecipe(name);
            }

            return <tr onClick={handleClick}>
                <td>{name}</td>
                <td>
                    {tags.map((tag) => (
                        <span
                            key={tag}
                            className="badge badge-pill badge-light mr-1"
                        >
                            {tag}
                        </span>
                    ))}
                </td>
            </tr>
        }

        function RecipeList({ recipes, setActiveRecipe, editMode }) {
            if (recipes == null || recipes.length === 0) {
                return <table class="table table-hover">
                    <tbody>
                        <tr>
                            <td>No recipes found</td>
                        </tr>
                    </tbody>
                </table>
            }

            return <table class="table table-hover">
                <tbody>
                    {recipes.map((recipe) => (
                        <RecipeRow
                            key={recipe.Name}
                            name={recipe.Name}
                            tags={recipe.Tags}
                            setActiveRecipe={setActiveRecipe}
                        />
                    ))}
                </tbody>
            </table>
        }

        function TagList({ tags, activeTags, inactiveTags, activateTag, deactivateTag }) {
            // Add onClick handlers to activate/deactivate tags when clicked
            function handleClickActivate(tag) {
                activateTag(tag, activeTags);
            }
            function handleClickDeactivate(tag) {
                deactivateTag(tag, activeTags);
            }
            function handleClickDeactivateAll() {
                activeTags.map((tag) => deactivateTag(tag, activeTags));
            }

            // Return a span for each tag in tags
            // Active tags go first in an emphasized color
            // Inactive tags go later in light color
            return <div>
                {activeTags.map((tag) => (
                    <span
                        key={tag}
                        className="badge badge-pill badge-primary mr-1"
                        onClick={() => handleClickDeactivate(tag)}
                    >
                        {tag}
                    </span>
                ))}
                {inactiveTags(tags, activeTags).map((tag) => (
                    <span
                        key={tag}
                        className="badge badge-pill badge-light mr-1"
                        onClick={() => handleClickActivate(tag)}
                    >
                        {tag}
                    </span>
                ))}
                {activeTags.length > 0 ? <span
                    key="clear-tags"
                    className="badge badge-pill badge-dark mr-1"
                    onClick={() => handleClickDeactivateAll()}
                >
                    clear all
                </span> : ""}
            </div>
        }

        function RecipePane({
            activeRecipe,
            editMode,
            creatingRecipe,
            setEditMode,
            setCreatingRecipe,
            setActiveRecipe,
            setActiveRecipeByName,
            refreshRecipeList,
            setRefreshRecipeList 
        }) {
            // Choose whether to render the display pane or the edit pane
            if (editMode) {
                return <RecipeEditPane activeRecipe={activeRecipe} creatingRecipe={creatingRecipe}
                    setEditMode={setEditMode} setCreatingRecipe={setCreatingRecipe}
                    setActiveRecipe={setActiveRecipe} setActiveRecipeByName={setActiveRecipeByName}
                    refreshRecipeList={refreshRecipeList} setRefreshRecipeList={setRefreshRecipeList} />
            } else {
                return <RecipeDisplayPane activeRecipe={activeRecipe} setEditMode={setEditMode} />
            }
        }

        function RecipeEditPane({ activeRecipe, creatingRecipe, setEditMode, setCreatingRecipe, setActiveRecipe, setActiveRecipeByName, refreshRecipeList, setRefreshRecipeList }) {
            // Define references for the name, ingredient, steps fields
            const nameRef = React.useRef(null);
            const ingredientsTextareaRef = React.useRef(null);
            const stepsTextareaRef = React.useRef(null);

            // Create a handler for disabling newlines in fields where we don't want those
            // (instead, we'd like to stop editing when the user hits enter)
            function handleEditNameKeyDown(event) {
                if (event.key === "Enter") {
                    event.preventDefault();
                    event.target.blur();
                }
            }

            function handleEditTagKeyDown(event) {
                // When the enter key is pressed, update the tag and de-focus the field
                if (event.key === "Enter") {
                    event.preventDefault();
                    event.target.blur();

                    // Update the tag in the recipe if it isn't blank (otherwise, remove it)
                    if (event.target.innerText.trim() === "") {
                        handleRemoveTag(event);
                        return;
                    }
                    activeRecipe = Object.assign({}, activeRecipe);
                    activeRecipe.Tags = activeRecipe.Tags.map((tag) => {
                        if (tag === event.target.id) {
                            return HtmlSanitizer.SanitizeHtml(event.target.innerText.trim());
                        } else {
                            return tag;
                        }
                    });
                    setActiveRecipe(activeRecipe);

                    // Update the field
                    event.target.innerText = HtmlSanitizer.SanitizeHtml(event.target.innerText.trim());
                } else if (event.key === "Escape") {
                    // If the user hits escape, cancel editing the tag
                    event.preventDefault();
                    event.target.blur();
                    event.target.innerText = event.target.id;
                }
            }

            function handleRemoveTag(event) {
                // Remove the tag from the recipe
                activeRecipe = Object.assign({}, activeRecipe);
                activeRecipe.Tags = activeRecipe.Tags.filter((tag) => tag !== event.target.id);
                setActiveRecipe(activeRecipe);
            }

            function handleAddTagKeyDown(event) {
                // When the enter key is pressed, add the new tag and de-focus the field
                if (event.key === "Enter") {
                    event.preventDefault();
                    event.target.blur();

                    // Add the tag to the recipe if it isn't blank
                    if (event.target.innerText.trim() === "") {
                        event.target.innerText = "+ Add tag";
                        return;
                    }

                    activeRecipe = Object.assign({}, activeRecipe);
                    activeRecipe.Tags.push(HtmlSanitizer.SanitizeHtml(event.target.innerText.trim()));
                    setActiveRecipe(activeRecipe);

                    // Clear the field
                    event.target.innerText = "+ Add tag";
                } else if (event.key === "Escape") {
                    // If the user hits escape, cancel editing the tag
                    event.preventDefault();
                    event.target.blur();
                    event.target.innerText = "+ Add tag";
                }
            }

            // Create a handler for updating the recipe's ingredients
            function handleIngredientsChange(event) {
                console.log(event)
            }

            // Create a function for parsing the ingredients field into an array of ingredients
            function parseIngredients(rawIngredientsText) {
                // Split the ingredients into lines
                const lines = rawIngredientsText.split("\n");

                // Parse each line into an ingredient
                var ingredients = lines.map((line) => {
                    // Split the line into name and quantity given the format
                    // "- name: quantity"
                    const split = line.split(":");
                    var name = HtmlSanitizer.SanitizeHtml(split[0].trim());
                    if (name.startsWith("- ")) {
                        name = name.substring(2);
                    }

                    var quantity = ""
                    if (split.length == 1) {
                        quantity = ""
                    } else {
                        quantity = HtmlSanitizer.SanitizeHtml(split[1].trim());
                    }

                    // Return the ingredient
                    return {
                        Quantity: quantity,
                        Name: name,
                    };
                });

                // Ignore any where the name is blank
                ingredients = ingredients.filter((ingredient) => ingredient.Name !== "");

                // Return the ingredients
                return ingredients;
            }

            // Create a handler for parsing the steps field into an array of steps
            function parseSteps(rawStepsText) {
                // Split the steps into lines
                const lines = rawStepsText.split("\n");

                // Parse each line into an instruction
                var steps = lines.map((line) => {
                    line = HtmlSanitizer.SanitizeHtml(line);

                    // Remove the leading "-" from the line
                    if (line.startsWith("-")) {
                        line = line.substring(1).trim();
                    }

                    // Return the step
                    return line.trim();
                });

                // Ignore any empty lines
                steps = steps.filter((step) => step !== "");

                // Return the steps
                return steps;
            }

            // Create a handler for the cancel button
            function handleCancelButton() {
                setEditMode(false);

                // If we were creating a recipe and cancel, don't display any recipe
                if (creatingRecipe) {
                    setActiveRecipe({});
                } else {
                    // Otherwise, refresh the recipe list
                    setRefreshRecipeList(!refreshRecipeList);

                    // And reset the active recipe to its clean version
                    setActiveRecipeByName(activeRecipe.Name);
                }

                // In any case, reset the creating recipe flag
                setCreatingRecipe(false);
            }

            // Create a handler for the save button
            function handleSaveButton() {
                activeRecipe = Object.assign({}, activeRecipe);

                // Parse the name
                activeRecipe.Name = HtmlSanitizer.SanitizeHtml(nameRef.current.innerText);

                // Parse the steps and ingredients
                activeRecipe.Ingredients = parseIngredients(ingredientsTextareaRef.current.value);
                activeRecipe.Steps = parseSteps(stepsTextareaRef.current.value);

                // Update the active recipe
                setActiveRecipe(activeRecipe);

                // PUT or POST activeRecipe depending on whether we're creating or editing
                if (creatingRecipe) {
                    // POST the recipe
                    fetch("/api/recipes", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify(activeRecipe),
                    })
                        .then((response) => response.json())
                        .then((data) => {
                            // Update the active recipe with the new ID
                            activeRecipe = Object.assign({}, activeRecipe);
                            activeRecipe.ID = data.ID;
                            setActiveRecipe(activeRecipe);
                        });
                } else {
                    // PUT the recipe
                    fetch("/api/recipes/id/" + activeRecipe.ID, {
                        method: "PUT",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify(activeRecipe),
                    });
                }

                // End editing mode
                setEditMode(false);
                setCreatingRecipe(false);

                // Refresh the recipes list
                setRefreshRecipeList(!refreshRecipeList);
            }

            return <div>
                <div class="mt-3 mb-3">
                    <h2 contentEditable={true} ref={nameRef}
                        onKeyDown={handleEditNameKeyDown} class="text-editable rounded">
                        {activeRecipe.Name}
                    </h2>
                    {activeRecipe.Tags.map((tag) => (
                        <span
                            key={tag}
                            className="badge badge-pill badge-light ml-3 text-editable"
                            id={tag}
                        >
                            <span className="mr-1 t-weight-bold text-primary" id={tag} onClick={handleRemoveTag}>&times;</span>
                            <span id={tag} contentEditable={true} onKeyDown={handleEditTagKeyDown}>{tag}</span>
                        </span>
                    ))}
                    <span
                        key="addTag"
                        className="badge badge-pill badge-light ml-3 text-editable"
                        contentEditable={true}
                        onKeyDown={handleAddTagKeyDown}
                        onFocus={(event) => event.target.innerText = " "}
                    >
                        + Add tag
                    </span>
                </div>
                <div>
                    <h3>Ingredients</h3>
                    <textarea class="rounded text-editable" style={{ width: "100%" }}
                        id="ingredients-list"
                        ref={ingredientsTextareaRef}
                        rows={activeRecipe.Ingredients.length + 1}
                        defaultValue={activeRecipe.Ingredients.map((ingredient) =>
                            ("- "
                            + ingredient.Name
                            + (ingredient.Quantity !== "" ? ":" : "")
                            + " "
                            + ingredient.Quantity)).join("\n")}>
                    </textarea>
                </div>
                <div>
                    <h3>Instructions</h3>
                    <textarea class="rounded text-editable" style={{ width: "100%" }}
                        id="steps-list"
                        ref={stepsTextareaRef}
                        rows={activeRecipe.Steps.length + 1}
                        defaultValue={activeRecipe.Steps.map((step) =>
                            ("- " + step)).join("\n")}>
                    </textarea>
                </div>
                <div>
                    <button type="button" onClick={handleSaveButton} class="btn btn-primary mb-3 mr-1">{creatingRecipe ? "Create" : "Save"} Recipe</button>
                    <button type="button" onClick={handleCancelButton} class="btn btn-secondary mb-3 mr-1">Cancel</button>
                </div>
            </div>
        }

        function RecipeDisplayPane({ activeRecipe, setEditMode }) {
            // If no recipe is selected, render an empty div
            if (activeRecipe === {} || activeRecipe.Name === undefined) {
                return <div class="mt-3 mb-3"></div>
            }

            // If the comments are undefined, set them to an empty array
            if (activeRecipe.Comments == undefined) {
                activeRecipe.Comments = [];
            }

            // Create an onClick handler for the edit button
            function handleEditButton() {
                setEditMode(true);
            }

            return <div>
                <div class="mt-3 mb-3">
                    <h2>{activeRecipe.Name}</h2>
                    {activeRecipe.Tags.map((tag) => (
                        <span
                            key={tag}
                            className="badge badge-pill badge-light ml-3"
                        >
                            {tag}
                        </span>
                    ))}
                </div>
                <div>
                    <h3>Ingredients</h3>
                    <ul>
                        {activeRecipe.Ingredients.map((ingredient) => (
                            <li key={ingredient.Name}>
                                {ingredient.Name}{ingredient.Quantity !== "" ? ":" : ""} {ingredient.Quantity}
                            </li>
                        ))}
                    </ul>
                </div>
                <div>
                    <h3>Instructions</h3>
                    <ol>
                        {activeRecipe.Steps.map((instruction) => (
                            <li key={instruction}>{instruction}</li>
                        ))}
                    </ol>
                </div>
                <div>
                    <button type="button" onClick={handleEditButton} class="btn btn-secondary mb-3 mr-1">Edit Recipe</button>
                    <button type="button" class="btn btn-danger mb-3 mr-1">Delete Recipe</button>
                </div>
                <div>
                    <h3>Comments</h3>
                    <div>
                        {activeRecipe.Comments.map((comment) => (
                            <div class="card mb-2 mr-2">
                                <div class="card-body">
                                    {comment.comment}
                                </div>
                                <div class="card-footer">
                                    <small class="text-muted">By {comment.author} on {comment.date}</small>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        }

        ReactDOM.render(<RecipeLibrary />, document.getElementById("recipeLibrary"));
    </script>
</body>

</html>